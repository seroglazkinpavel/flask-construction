## Описание создания проекта на Flask.
### Задание
1. Создать сайт-визитку на тему: "Бригада отделочников". Сайт должен состоять из следующих страниц: главная, цены, фото наших работ, контакты, отзывы
2. Функционал: авторизация/регистрация пользователей; отзывы с созданием, изменением, удалением комментарий; пагинация на страницу отзывов.
3. Разработать дизайн адаптивного сайта с логотипом и иконкой. Сверстать.
4. Перенести готовый проект на удаленный сервер timeweb.
   
### Этапы создания проекта

Создаем проект на рабочем столе с названием "flask-construction", с переходом в папку проекта, команда в терминале

```
> mkdir flask-construction
> cd flask-construction
```

Установим: вертуальное окружение и его активацию, пакет Fkask

```
> python -m venv venv
> .\venv\Scripts\activate
> pip install Flask
```
__Пропишим файл app.py__

Создаем WSGI-приложение в файле app.py. Импортируем из модуля flask класс Flask. Экземпляр этого класса будет нашим WSGI-приложением. Создадим экземпляр этого класса и сохраним его в переменную app. Передадим классу имя модуля ```__name__```

Настроим защиту от CSRF-атак. Для включения защиты от CSRF-атак в Flask-WTF установим секретный ключ приложения. В python console IDE проделаем следующие действия для создания секретного ключа

```
>>> import secrets
>>> secrets.token_hex()
```
Создаем объект csrf и передаем ему приложение Flask. Устанавливаем секретный ключ приложения. После этого защита от CSRF-атак будет включена для всех форм в приложении.

Тип базы данных будем использовать MySQL. Пропишим адрес БД. Для инициализации баз данных необходимо выполнить строку ```bd.init_app(app)```.

Свяжем экземпляр login (см. файл models.py) с нашим приложением ```login.init_app(app)```. После этого сообщим ```Flask_login``` о странице; не прошедшие проверку пользователи будут перенаправлены, что будет ничем иным, как самой страницей входа ```login.login_view = 'login'```.

Создаем представления для обработки запросов пользователя. В декораторе ```@app.route``` указываем url адрес по которому будем обрабатывать данный обработчик в виде функций:
- index() возвращает главную страницу
- contacts() возвращает контакты
- photos_of_our_works() возвращает фото наших работ
- reviews() возвращает отзывы и пагинацию страниц
- price() возвращает страницу стоимость работ
- init_db() с декоратором ```@app.cli.command("init-db")``` создает таблицы базы данных. Вызывается командой ```flask init-db```
- login() возвращает страницу авторизации
- register() возвращает страницу регистрации
- panel() возвращает страницу отзывов
- edit_comment(comment_id) возвращает страницу обновление отзыва
- deleta_comment(comment_id) удаляет отзыв
- logout() производит выход из авторизации и переход на главную страницу.

Все html - файлы хранятся в виде отдельных файлов и загружаются по мере небходимости. Будем использовать для шаблонов стандартный модуль Jinja2. Чтобы воспользоваться шаблонизатором нужно импортировать его элемент render_template. Функция render_templete после имени шаблона принимает словарь с переменными, который перебрасываем в шаблон его распакованный вид. Все шаблоны находятся в каталоге templates. Для корректного отображения кирилицы все шаблоны будем сохранять в кодировке utf-8. В шаблонах отоображаем информацию в виде параметров, а в обработчике указываем эти параметры. Определим базовый шаблон страницы файл base.html. Воспользуемся механизмом расширения (иследование) шаблона для создания дочерних страниц сайта.


С помощью функции url_for() подключим внешние ресурсы (js, css, images), а так же в шаблонах пропишем url адреса сылок. Эту функцию будем импортировать в проект. Внешние ресурсы расположим в каталоге static. Каталоги tamplates и static распологаются на одном уровне. 

__Пропишим файл models.py__ 

При работе с базой данных применим расширение Flask-SQLAlchemy, установим и импортируем его ```pip install Flask-SQLAlchemy```. Будем использовать тип данных DATETIME для даты и времени. Импортируем datetime. Для хэширования паролей используем две вспомогательные функции: ```generate_password_hash(password)```, которая принимает пароль и возвращает хэш; check_password_hash(password_hash, password) принимает хэш и пароль в чистом виде, затем сравнивает password и password_hash, если они одинаковые, возвращает True. Для этого импортируем werkzeug. Эти методы пропишем в классе User.

Для аутентификации пользователя используем библиотеку Flask-Login и устанавливаем ее ```pip install flask-login```. Также используем UserMixin из библиотеки flask_login. UserMixin имеет встроенные функции, которые мы будем использовать (is_authenticated: Return True если у пользователя есть действительные учетные данные).

Создадим и инициализируем расширение Flask_login. Для этого импортируем LoginManager из flask_login и прописываем ```login = LoginManager()```. Создаем объект db класса SQLAlchemy.

Flask хранит __идентификатор пользователя__ вошедших в сеанс пользователей. Поскольку Flask_Login ничего не знает о базах данных, создаем функцию для их связи user_loader.

Определим модели данных и создадим классы, которые наследуются от класса Model из библиотеки SQLAlchemy. Название класса будет соответствовать названию таблицы в базе данных. Создадим следующие классы:
- User пользователи. Имеют 5 полей: id, username, email, password_hash, created_at и три метода. Поля id являются первичным ключом таблицы и автоматически генерируются при добавлении записи в таблицу. Поля usrename, email и password_hash явлыются строками. Поле create_at содержит дату и время создания записи и автоматически заполняется текущей датой и временем при добавлении записи
- Comment комментарии, имеют 4 поля: id, text, author, created_at и один метод __repr__ для получения строкового представления объекта. Поля id и create_at описаны выше. Поле text текстовое поле. Поле author строковое, уникальное, с повышенной эффективностью запроса. Оба поля text и author не допускают значение NULL
- Works расценка работы, имеет 4 поля: id, titlt, unit_dimensions, price и метод __repr__. Поля, кроме id, не допускают значение NULL. Поля title и unit_dimensions являются строковыми. Поле price является целым числом.

Напишим функцию init_db() (находится в файле app.py):, которая создаст таблицы через консольную команду ```flask init-db```.

__Пропишим файл forms.py__

Установим расширение WTForms ```pip install flask_wtf```. Для Flask оно называется Flask-WTF. WTForms – это библиотека, написанная на Python и независимая от фреймворков. Она способна генерировать формы, проверять их, наполнять начальной информацией, работать с reCaptcha и многое другое. Кроме того, в нее встроена защита от CSRF. Концепция создания форм здесь состоит в расширении базового класса FlaskForm. После установки модуля его надо импортировать. Настройка защиты от CSRF-атак была прописана в файле app.py

Определим классы форм, которые наследуется от класса FlaskForm. Каждое поле формы определяется как экземпляр класса, который наследуется от класса Field. Пропишем следующие классы:  
- LoginForm форма авторизации, имеет три поля: username, email, password. Каждое поле ссылаются на соответствующие объекты: StringField, StringField, PasswordField, которые импортируем из wtforms в файл forms.py. У каждого объекта вначале указана строка, которую, затем, можно будет отобразить рядом с полем ввода и параметр validators. Этот параметр содержит список валидаторов, с помощью которых выполняется проверка корректности введенных данных. Во всех трех поля используется DataRequired – валидатор, требующий ввода каких-либо данных; Email – проверяет корректность введенного email-адреса. Email требует отдельной дополнительной установки: ```pip install email-validator```. Импортируем валидаторы из wtforms.validators в forms.py. Созданный класс LoginForm импортируем в app.py и будем использовать его в функции представления login(). 

